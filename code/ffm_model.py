from sklearn.model_selection import train_test_split
import os
import pandas as pd
import glob

FFM_PATH = '/home/nfs/jiweil/tools/libsffm'
IDCOL = 'MachineIdentifier'
YCOL = 'HasDetections'

def mkdir(path):
    if os.path.exists(path)==0:
        os.mkdir(path)

def mkdf(x,y,names):
    df = pd.DataFrame(x,columns=names)
    if y is not None:
        df[YCOL] = y
    return df

class FFM:
    def __init__(self,**kwargs):
        self.params = kwargs 
        self.cache = self.params['cache']
        self.path = self.params['path']
        self.mode = self.params['mode']
        mkdir(self.cache)

    def fit_predict(self):
        out = '%s.csv'%(self.mode)
        self.out = '%s/%s'%(self.cache,out)
        self.encode()
        self.write_sample()
        self._fit_predict() 
        return pd.read_csv(self.out)['pred'].values

    def write_sample(self):
        if self.mode=='sub':
            out = self.va_name.replace('.ffm','_sample.ffm')
            if os.path.exists(out):
                return
            fo = open(out,'w')
            with open(self.va_name,'r') as f:
                for c,line in enumerate(f):
                    fo.write(line)
                    if c>100:
                        break
            fo.close()

    def encode(self):
        if self.mode == 'cv':
            tr,va = 'tr','va'
        else:
            tr,va = 'train','test'
        tr_path = '%s/%s.csv'%(self.path,tr)
        va_path = '%s/%s.csv'%(self.path,va)
        self.tr_name = '%s/%s.ffm'%(self.cache,tr)
        self.va_name = '%s/%s.ffm'%(self.cache,va)
        cmd = 'pypy ffm_utils.py %s %s %s %s %s %s'%(IDCOL,YCOL,tr_path,va_path,self.tr_name,self.va_name)
        print(cmd)
        os.system(cmd)

    def _fit_predict(self):
        cmd = ['%s/ffm-train-predict'%FFM_PATH] 
        if self.params.get('autostop',0)>0:
            cmd.append('-auto-stop %d'%self.params['autostop'])
        if self.params.get('metric','logloss') in ['auc','mcc','gini']:
            cmd.append('--%s'%self.params['metric'])
        if self.params.get('train_batch',0):
            cmd.append('--trainbatch')
        if self.params.get('objective','binary') == 'regression':
            cmd.append('--regression')
        if 'max_feature' in self.params:
            cmd.append('-max_feature %d'%self.params['max_feature'])
        if 'fmap' in self.params:
            cmd.append('-fmap %s'%self.params['fmap'])
        if 'savefield' in self.params:
            cmd.append('-savefield %d'%self.params['savefield'])
        cmd.append('-s %d'%self.params['threads'])
        cmd.append('-t %d'%self.params['epochs'])
        cmd.append('-r %f'%self.params['lr'])
        cmd.append('-l %f'%self.params.get('lambda',0.0001))
        cmd.append('-k %d'%self.params['embedding_size'])
        if self.params.get('va',1):
            va_name = self.va_name if self.mode=='cv' else self.va_name.replace('.ffm','_sample.ffm')
            cmd.append('-p %s'%va_name)
        cmd.append('--train_only')
        self.model_name = "%s/%s.model"%(self.cache,self.mode)
        cmd.append('%s %s'%(self.tr_name,self.model_name))
        out = " ".join(cmd)
        #if os.path.exists('%s'%(self.model_name)):
        #    print("model exist")
        #    return self
        print(out)
        os.system(out)
        tmp = cmd[:-2]+['-test %s'%self.va_name,'-out %s'%self.out]+cmd[-1:]
        cmd = " ".join(tmp)
        print(cmd)
        if os.path.exists(self.out)==False:
            os.system(cmd)
  
