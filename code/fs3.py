from malware_model import build,METRIC,get_score,mtr_encode,YCOL,count_encode2way,reset_col_dtype,get_tr_te_paths,read_csv_hash_nvstring,count_encode 
import cudf as gd
from ml_robot import timer
import os
import pandas as pd
import numpy as np
from bs import bslog,fit_predict

#COL = 'CityIdentifier'
#COL = 'AVProductStatesIdentifier'
#COL = 'Census_ProcessorModelIdentifier'
#COL = 'Census_OSInstallTypeName'
COL = 'OrganizationIdentifier'
#COL = 'AppVersion' 
#COL = 'EngineVersion'
os.environ['CUDA_VISIBLE_DEVICES'] = '6'
def fw(model_name):
    good = []#['mtr_AVProductStatesIdentifier','mtr_CountryIdentifier']
    mode = 'cv'
    bad = [COL]+['AvSigVersion','Census_OSVersion']#,'Census_ProcessorModelIdentifier']
    Xa,Xta = read_avsig()       
    X,Xt,y,yt,names,tr_id,te_id = build(mode,build_list=[6,1,4],cache=[0,0,0]) 
    yp,model = fit_predict(names,X,y,Xt,yt,model_name=model_name)
    del model
    best = get_score(yt,yp,METRIC)
    #best = 100
    N = X.shape[1]
    print('best %.4f'%best)
    names2 = names.copy()
    for i in range(N):
        bf = None
        for c,col in enumerate(names2):
            c = len(good)+c
            if col.startswith('mtr_') or col.startswith('count_') or col.startswith('emb_'):
                continue
            if col in bad:
                continue
            xcol = col
            col = 'count-%s-%s'%(COL,col)
            if col in good:
                continue
            X1,X1t = build_new_fea(Xa,Xta,X[:,c],Xt[:,c])
            if X1.shape[1] == 0:
                continue
            X_tmp = np.hstack([X1,X])
            Xt_tmp = np.hstack([X1t,Xt])
            names_tmp = names + [col]
            yp,model = fit_predict(names_tmp,X_tmp,y,Xt_tmp,yt,model_name=model_name)
            del model
            score = get_score(yt,yp,METRIC)
            #score = 0
            print('bad',bad,'\n')
            print(good+[col],score,best,'\n')
            bslog(good+[col],score,'fs_count_%s.log'%COL)
            if score<best-0.0015:
                bad.append(xcol)
            if best<score:
                best = score
                bf = col
                Xb = X1.copy()
                Xtb = X1t.copy()
        if bf is None:
            break
        good.append(bf)
        #names.append(bf)
        names = [bf] + names
        X,Xt = np.hstack([Xb,X]),np.hstack([Xtb,Xt])

@timer
def build_new_fea(xa,xta,x,xt):
    N = len(x)
    #x = np.concatenate([x,xt])
    gtr = gd.DataFrame()
    gtr['x'] = np.ascontiguousarray(x)
    gtr['xa'] = np.ascontiguousarray(xa[:,0])
    gtr['xb'] = np.ascontiguousarray(xa[:,1])
    gte = gd.DataFrame()
    gte['x'] = np.ascontiguousarray(xt)
    gte['xa'] = np.ascontiguousarray(xta[:,0])
    gte['xb'] = np.ascontiguousarray(xta[:,1])
    acol = ['xa','x','xb']
    count_cols = [acol] 

    gtr,gte = reset_col_dtype(gtr,gte)
    df = gd.concat([gtr,gte])
    del gtr,gte
    print("# o_f count cols",len(count_cols))
    df = count_encode(df,['xa'],keep=acol)
    df = count_encode2way(df,count_cols)
    data = df.to_pandas()
    del df
    tag = 'count_%s'%('_'.join(acol))
    data[tag] = data[tag]/data['count_xa']
    print(tag,data[tag].max())
    assert data[tag].max()<=1.0 
    data.drop('count_xa',axis=1,inplace=True)
    data = data.values
    return data[:N],data[N:]

def read_avsig():
    mode = 'cv'
    col = ['AvSigVersion']+[COL]
    tr_path,te_path = get_tr_te_paths(mode)
    gtr,_ = read_csv_hash_nvstring(tr_path)
    gte,_ = read_csv_hash_nvstring(te_path)    
    x = gtr[col].to_pandas().values
    xt = gte[col].to_pandas().values
    del gtr,gte
    return x,xt

if __name__ == '__main__':
    fw('xgb')
