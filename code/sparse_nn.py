import tensorflow as tf
from random import shuffle
import numpy as np
from scipy import sparse
from ml_robot import SKTFModel
from malnet import MalNN
import warnings
warnings.filterwarnings("ignore")

class SparseNN(MalNN):

    def _build(self):
        name = 'SNN'
        print(self.X.shape)
        SF = self.X.shape[1]
        self.inputs = tf.placeholder(tf.float32,shape=[None,SF])
        net = self.inputs

        Hs = self.params['Hs']
        D = self.params.get('drop_prob',0.25)
        C = self.params.get('classes',1)
        As = ['relu' for i in Hs]
        Ds = [D for i in Hs]
        Ds[-1] = 0

        with tf.variable_scope(name):
            net = self._fc(net, 50, layer_name='%s/fc1'%name,activation='relu')
            #net = self._batch_normalization(net, layer_name='%s/bn0'%name)
            net = self._fc(net, 25, layer_name='%s/fc2'%name,activation='relu')#,use_mask = True,thresh=0.002)
            #net = self._batch_normalization(net, layer_name='%s/bn1'%name)
            net = self._fc(net, 1, layer_name='%s/fc'%name,activation=None)#,use_mask = True,thresh=0.1)


            #for c,(h,a,d) in enumerate(zip(Hs,As,Ds)):
            #    net = self.fcblock(net,h,name,c+1,a,d)
            #net = self._fc(net, C, layer_name='%s/out'%(netname))
        return tf.squeeze(net)

    def process_x(self,x):
        return x.toarray()


if __name__ == '__main__':
    x = np.array([[0,0,1,1],[1,0,0,0],[1,1,0,0],[1,1,1,0]])
    x = sparse.csr_matrix(x)
    y = np.array([1,0,1,0])
    print(x.shape,y.shape,type(x),isinstance(x,sparse.csr_matrix))
    snn = SparseNN(batch_size=2,objective='regression',metric='rmse')
    snn.fit(x,y)
