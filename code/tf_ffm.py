import tensorflow as tf
from random import shuffle
import numpy as np
import random
from malnet import MalNN
import os
import warnings
warnings.filterwarnings("ignore")

class TF_FFM(MalNN):

    def _batch_gen_train(self):
        X,y = self.X,self.y
        ids = [i for i in range(X.shape[0])]
        epochs = self.flags.epochs
        m = len(ids)-1
        B = self.flags.batch_size
        batches = X.shape[0]//B
        tbn = batches*epochs
        print("Epochs:%d Total Batches:%d Batch Size:%d"%(self.flags.epochs,tbn,self.flags.batch_size))
        for epoch in range(epochs):
            shuffle(ids)
            for i in range(batches):
                idx = ids[i*B:(i+1)*B]
                if self.params.get('random_label',0):
                    yr = y[idx].copy()
                    thresh = random.random()
                    yr[yr>thresh] = 1
                    yr[yr<thresh] = 0
                    yield X[idx],yr,epoch,i==batches-1
                else:
                    yield X[idx],y[idx],epoch,i==batches-1

    def _build(self):
        netname = "FFM"
        voc_size,_ = self.get_voc_size()

        Hs = self.params['Hs']
        D = self.params.get('drop_prob',0.25)
        C = self.params.get('classes',1)
        As = ['relu' for i in Hs]
        Ds = [D for i in Hs]
        Ds[-1] = 0

        M = self.params['catfeas']
        K = self.params['embedding_size'] # length of latent vector
        SF = self.X.shape[1]  
        self.inputs = tf.placeholder(tf.float32,shape=[None,SF])
        cat = self.inputs[:,:M]
        cat = tf.cast(cat,tf.int32)
        num = self.inputs[:,M:]

        B = tf.shape(self.inputs)[0]
        net = self.inputs
        #mask = self.get_mask(M,K) # [1,M,M,K]
        with tf.variable_scope(netname):
            cxs = []
            for c,net in enumerate(tf.split(cat,M,axis=1)):
                name = 'cat_%d'%c
                tmp = self._get_embedding("%s/%s"%(netname,name),net,voc_size[c],K*M,train_missing=True)
                #cxs.append(tf.reshape(tmp,[B,]))
                cxs.append(tmp)
            cnet = tf.concat(cxs,axis=1)
            # cnet is [B,M,M*K]
            net = tf.reshape(cnet,[B,M,M,K])#*mask # set diagnol to zero
            net1 = tf.transpose(net, perm=[0,2,1,3])
            net = net*net1
            net = tf.reduce_sum(net,-1)

            ones = tf.ones_like(net)
            mask_a = tf.matrix_band_part(ones, 0, -1) # Upper triangular matrix of 0s and 1s
            mask_b = tf.matrix_band_part(ones, 0, 0)  # Diagonal matrix of 0s and 1s
            mask = tf.cast(mask_a - mask_b, dtype=tf.bool) # Make a bool mask

            net = tf.boolean_mask(net, mask)
            net = tf.reshape(net,[B,M*(M-1)//2])
            if self.params.get('bottleneck',0):
                return net
            return tf.reduce_sum(net,axis=-1)

    def get_mask(self,M,K):
        mask = np.ones([M,M,K])
        ids = np.arange(M)
        mask[ids,ids,:] = 0
        mask = tf.get_variable('mask',shape=[M,M,K],
            initializer=tf.constant_initializer(value=mask,dtype=tf.float32),trainable=False)
        return tf.expand_dims(mask + 0, 0) 
